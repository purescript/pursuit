{"uploader":null,"packageMeta":{"homepage":"https://github.com/purescript/purescript-prelude","repository":{"url":"git://github.com/purescript/purescript-prelude.git","type":"git"},"ignore":["**/.*","bower_components","node_modules","output","test","bower.json","gulpfile.js","package.json"],"name":"purescript-prelude","keywords":["purescript"],"description":"The PureScript Prelude"},"modules":[{"name":"Prelude","comments":null,"declarations":[{"children":[{"comments":null,"title":"semigroupUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Semigroup"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[406,1],"name":"src/Prelude.purs","end":[409,1]}},{"comments":null,"title":"semiringUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Semiring"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[457,1],"name":"src/Prelude.purs","end":[463,1]}},{"comments":null,"title":"ringUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ring"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[495,1],"name":"src/Prelude.purs","end":[498,1]}},{"comments":null,"title":"moduloSemiringUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.ModuloSemiring"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[530,1],"name":"src/Prelude.purs","end":[534,1]}},{"comments":null,"title":"divisionRingUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.DivisionRing"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[556,1],"name":"src/Prelude.purs","end":[564,1]}},{"comments":null,"title":"numUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Num"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[567,1],"name":"src/Prelude.purs","end":[576,1]}},{"comments":null,"title":"eqUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Eq"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[606,1],"name":"src/Prelude.purs","end":[609,1]}},{"comments":null,"title":"ordUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ord"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[656,1],"name":"src/Prelude.purs","end":[659,1]}},{"comments":null,"title":"boundedUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Bounded"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[727,1],"name":"src/Prelude.purs","end":[731,1]}},{"comments":null,"title":"boundedOrdUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.BoundedOrd"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[751,1],"name":"src/Prelude.purs","end":[752,1]}},{"comments":null,"title":"booleanAlgebraUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.BooleanAlgebra"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[794,1],"name":"src/Prelude.purs","end":[799,1]}},{"comments":null,"title":"showUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Show"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[844,1],"name":"src/Prelude.purs","end":[847,1]}}],"comments":"The `Unit` type has a single inhabitant, called `unit`. It represents\nvalues with no computational content.\n\n`Unit` is often used, wrapped in a monadic type constructor, as the\nreturn type of a computation where only\nthe _effects_ are important.\n","title":"Unit","fixity":null,"info":{"declType":"data","dataDeclType":"newtype","typeArguments":[]},"sourceSpan":{"start":[35,1],"name":"src/Prelude.purs","end":[38,1]}},{"children":[],"comments":"`unit` is the sole inhabitant of the `Unit` type.\n","title":"unit","fixity":null,"info":{"declType":"value","type":{"tag":"TypeConstructor","contents":"Prelude.Unit"}},"sourceSpan":{"start":[38,1],"name":"src/Prelude.purs","end":[39,1]}},{"children":[],"comments":"Applies a function to its argument.\n\n```purescript\nlength $ groupBy productCategory $ filter isInStock $ products\n```\n\nis equivalent to:\n\n```purescript\nlength (groupBy productCategory (filter isInStock products))\n```\n\n`($)` is different from [`(#)`](#-2) because it is right-infix instead of\nleft: `a $ b $ c $ d x = a $ (b $ (c $ (d $ x))) = a (b (c (d x)))`\n","title":"($)","fixity":{"associativity":"infixr","precedence":0},"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[58,1],"name":"src/Prelude.purs","end":[59,1]}},{"children":[],"comments":"Applies an argument to a function.\n\n```purescript\nproducts # filter isInStock # groupBy productCategory # length\n```\n\nis equivalent to:\n\n```purescript\nlength (groupBy productCategory (filter isInStock products))\n```\n\n`(#)` is different from [`($)`](#-1) because it is left-infix instead of\nright: `x # a # b # c # d = (((x # a) # b) # c) # d = d (c (b (a x)))`\n","title":"(#)","fixity":{"associativity":"infixl","precedence":1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]},{"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[75,1],"name":"src/Prelude.purs","end":[76,1]}},{"children":[],"comments":"Flips the order of the arguments to a function of two arguments.\n\n```purescript\nflip const 1 2 = const 2 1 = 2\n```\n","title":"flip","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["c",{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"c"}]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"c"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[83,1],"name":"src/Prelude.purs","end":[84,1]}},{"children":[],"comments":"Returns its first argument and ignores its second.\n\n```purescript\nconst 1 \"hello\" = 1\n```\n","title":"const","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[91,1],"name":"src/Prelude.purs","end":[92,1]}},{"children":[],"comments":"This function returns its first argument, and can be used to assert type\nequalities. This can be useful when types are otherwise ambiguous.\n\n```purescript\nmain = print $ [] `asTypeOf` [0]\n```\n\nIf instead, we had written `main = print []`, the type of the argument\n`[]` would have been ambiguous, resulting in a compile-time error.\n","title":"asTypeOf","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]},null]}},"sourceSpan":{"start":[103,1],"name":"src/Prelude.purs","end":[104,1]}},{"children":[],"comments":"An alias for `true`, which can be useful in guard clauses:\n\n```purescript\nmax x y | x >= y    = x\n        | otherwise = y\n```\n","title":"otherwise","fixity":null,"info":{"declType":"value","type":{"tag":"TypeConstructor","contents":"Prim.Boolean"}},"sourceSpan":{"start":[112,1],"name":"src/Prelude.purs","end":[113,1]}},{"children":[{"comments":null,"title":"compose","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["d",{"tag":"ForAll","contents":["c",{"tag":"ForAll","contents":["b",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"c"}]},{"tag":"TypeVar","contents":"d"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"c"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"d"}]}]}]},null]},null]},null]}},"sourceSpan":null},{"comments":null,"title":"semigroupoidFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Semigroupoid"},{"tag":"TypeConstructor","contents":"Prim.Function"}]}},"sourceSpan":{"start":[127,1],"name":"src/Prelude.purs","end":[130,1]}}],"comments":"A `Semigroupoid` is similar to a [`Category`](#category) but does not\nrequire an identity element `id`, just composable morphisms.\n\n`Semigroupoid`s must satisfy the following law:\n\n- Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`\n\nOne example of a `Semigroupoid` is the function type constructor `(->)`,\nwith `(<<<)` defined as function composition.\n","title":"Semigroupoid","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[124,1],"name":"src/Prelude.purs","end":[127,1]}},{"children":[],"comments":"`(<<<)` is an alias for `compose`.\n","title":"(<<<)","fixity":{"associativity":"infixr","precedence":9},"info":{"declType":"value","type":{"tag":"ForAll","contents":["d",{"tag":"ForAll","contents":["c",{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.Semigroupoid",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"c"}]},{"tag":"TypeVar","contents":"d"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"c"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"d"}]}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[134,1],"name":"src/Prelude.purs","end":[135,1]}},{"children":[],"comments":"Forwards composition, or `(<<<)` with its arguments reversed.\n","title":"(>>>)","fixity":{"associativity":"infixr","precedence":9},"info":{"declType":"value","type":{"tag":"ForAll","contents":["d",{"tag":"ForAll","contents":["c",{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.Semigroupoid",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"c"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"c"}]},{"tag":"TypeVar","contents":"d"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"d"}]}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[138,1],"name":"src/Prelude.purs","end":[139,1]}},{"children":[{"comments":null,"title":"id","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["t",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"t"}]},{"tag":"TypeVar","contents":"t"}]},null]}},"sourceSpan":null},{"comments":null,"title":"categoryFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Category"},{"tag":"TypeConstructor","contents":"Prim.Function"}]}},"sourceSpan":{"start":[152,1],"name":"src/Prelude.purs","end":[166,1]}}],"comments":"`Category`s consist of objects and composable morphisms between them, and\nas such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`\nmust have an identity element.\n\nInstances must satisfy the following law in addition to the\n`Semigroupoid` law:\n\n- Identity: `id <<< p = p <<< id = p`\n","title":"Category","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[["Prelude.Semigroupoid",[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[149,1],"name":"src/Prelude.purs","end":[152,1]}},{"children":[{"comments":null,"title":"map","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"b"}]}]}]},null]},null]}},"sourceSpan":null},{"comments":null,"title":"functorFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Functor"},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"r"}]}]}},"sourceSpan":{"start":[169,1],"name":"src/Prelude.purs","end":[172,1]}},{"comments":null,"title":"functorArray","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Functor"},{"tag":"TypeConstructor","contents":"Prim.Array"}]}},"sourceSpan":{"start":[172,1],"name":"src/Prelude.purs","end":[175,1]}}],"comments":"A `Functor` is a type constructor which supports a mapping operation\n`(<$>)`.\n\n`(<$>)` can be used to turn functions `a -> b` into functions\n`f a -> f b` whose argument and return types use the type constructor `f`\nto represent some computational context.\n\nInstances must satisfy the following laws:\n\n- Identity: `(<$>) id = id`\n- Composition: `(<$>) (f <<< g) = (f <$>) <<< (g <$>)`\n","title":"Functor","fixity":null,"info":{"arguments":[["f",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[166,1],"name":"src/Prelude.purs","end":[169,1]}},{"children":[],"comments":"`(<$>)` is an alias for `map`\n","title":"(<$>)","fixity":{"associativity":"infixl","precedence":4},"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["f",{"tag":"ConstrainedType","contents":[[["Prelude.Functor",[{"tag":"TypeVar","contents":"f"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[181,1],"name":"src/Prelude.purs","end":[182,1]}},{"children":[],"comments":"`(<#>)` is `(<$>)` with its arguments reversed. For example:\n\n```purescript\n[1, 2, 3] <#> \\n -> n * n\n```\n","title":"(<#>)","fixity":{"associativity":"infixl","precedence":1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["f",{"tag":"ConstrainedType","contents":[[["Prelude.Functor",[{"tag":"TypeVar","contents":"f"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[189,1],"name":"src/Prelude.purs","end":[190,1]}},{"children":[],"comments":"The `void` function is used to ignore the type wrapped by a\n[`Functor`](#functor), replacing it with `Unit` and keeping only the type\ninformation provided by the type constructor itself.\n\n`void` is often useful when using `do` notation to change the return type\nof a monadic computation:\n\n```purescript\nmain = forE 1 10 \\n -> void do\n  print n\n  print (n * n)\n```\n","title":"void","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["f",{"tag":"ConstrainedType","contents":[[["Prelude.Functor",[{"tag":"TypeVar","contents":"f"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}]}]},null]},null]}},"sourceSpan":{"start":[204,1],"name":"src/Prelude.purs","end":[205,1]}},{"children":[{"comments":null,"title":"apply","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"b"}]}]}]},null]},null]}},"sourceSpan":null},{"comments":null,"title":"applyFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Apply"},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"r"}]}]}},"sourceSpan":{"start":[232,1],"name":"src/Prelude.purs","end":[235,1]}},{"comments":null,"title":"applyArray","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Apply"},{"tag":"TypeConstructor","contents":"Prim.Array"}]}},"sourceSpan":{"start":[235,1],"name":"src/Prelude.purs","end":[238,1]}}],"comments":"The `Apply` class provides the `(<*>)` which is used to apply a function\nto an argument under a type constructor.\n\n`Apply` can be used to lift functions of two or more arguments to work on\nvalues wrapped with the type constructor `f`. It might also be understood\nin terms of the `lift2` function:\n\n```purescript\nlift2 :: forall f a b c. (Apply f) => (a -> b -> c) -> f a -> f b -> f c\nlift2 f a b = f <$> a <*> b\n```\n\n`(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts\nthe function application operator `($)` to arguments wrapped with the\ntype constructor `f`.\n\nInstances must satisfy the following law in addition to the `Functor`\nlaws:\n\n- Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`\n\nFormally, `Apply` represents a strong lax semi-monoidal endofunctor.\n","title":"Apply","fixity":null,"info":{"arguments":[["f",null]],"declType":"typeClass","superclasses":[["Prelude.Functor",[{"tag":"TypeVar","contents":"f"}]]]},"sourceSpan":{"start":[229,1],"name":"src/Prelude.purs","end":[232,1]}},{"children":[],"comments":"`(<*>)` is an alias for `apply`.\n","title":"(<*>)","fixity":{"associativity":"infixl","precedence":4},"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["f",{"tag":"ConstrainedType","contents":[[["Prelude.Apply",[{"tag":"TypeVar","contents":"f"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[241,1],"name":"src/Prelude.purs","end":[242,1]}},{"children":[{"comments":null,"title":"pure","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},null]}},"sourceSpan":null},{"comments":null,"title":"applicativeFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Applicative"},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"r"}]}]}},"sourceSpan":{"start":[265,1],"name":"src/Prelude.purs","end":[268,1]}},{"comments":null,"title":"applicativeArray","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Applicative"},{"tag":"TypeConstructor","contents":"Prim.Array"}]}},"sourceSpan":{"start":[268,1],"name":"src/Prelude.purs","end":[272,1]}}],"comments":"The `Applicative` type class extends the [`Apply`](#apply) type class\nwith a `pure` function, which can be used to create values of type `f a`\nfrom values of type `a`.\n\nWhere [`Apply`](#apply) provides the ability to lift functions of two or\nmore arguments to functions whose arguments are wrapped using `f`, and\n[`Functor`](#functor) provides the ability to lift functions of one\nargument, `pure` can be seen as the function which lifts functions of\n_zero_ arguments. That is, `Applicative` functors support a lifting\noperation for any number of function arguments.\n\nInstances must satisfy the following laws in addition to the `Apply`\nlaws:\n\n- Identity: `(pure id) <*> v = v`\n- Composition: `(pure <<<) <*> f <*> g <*> h = f <*> (g <*> h)`\n- Homomorphism: `(pure f) <*> (pure x) = pure (f x)`\n- Interchange: `u <*> (pure y) = (pure ($ y)) <*> u`\n","title":"Applicative","fixity":null,"info":{"arguments":[["f",null]],"declType":"typeClass","superclasses":[["Prelude.Apply",[{"tag":"TypeVar","contents":"f"}]]]},"sourceSpan":{"start":[262,1],"name":"src/Prelude.purs","end":[265,1]}},{"children":[],"comments":"`return` is an alias for `pure`.\n","title":"return","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[[["Prelude.Applicative",[{"tag":"TypeVar","contents":"m"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"a"}]}]}]},null]},null]}},"sourceSpan":{"start":[272,1],"name":"src/Prelude.purs","end":[273,1]}},{"children":[],"comments":"`liftA1` provides a default implementation of `(<$>)` for any\n[`Applicative`](#applicative) functor, without using `(<$>)` as provided\nby the [`Functor`](#functor)-[`Applicative`](#applicative) superclass\nrelationship.\n\n`liftA1` can therefore be used to write [`Functor`](#functor) instances\nas follows:\n\n```purescript\ninstance functorF :: Functor F where\n  map = liftA1\n```\n","title":"liftA1","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["f",{"tag":"ConstrainedType","contents":[[["Prelude.Applicative",[{"tag":"TypeVar","contents":"f"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[287,1],"name":"src/Prelude.purs","end":[288,1]}},{"children":[{"comments":null,"title":"bind","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"b"}]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"b"}]}]}]},null]},null]}},"sourceSpan":null},{"comments":null,"title":"bindFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Bind"},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"r"}]}]}},"sourceSpan":{"start":[319,1],"name":"src/Prelude.purs","end":[322,1]}},{"comments":null,"title":"bindArray","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Bind"},{"tag":"TypeConstructor","contents":"Prim.Array"}]}},"sourceSpan":{"start":[322,1],"name":"src/Prelude.purs","end":[325,1]}}],"comments":"The `Bind` type class extends the [`Apply`](#apply) type class with a\n\"bind\" operation `(>>=)` which composes computations in sequence, using\nthe return value of one computation to determine the next computation.\n\nThe `>>=` operator can also be expressed using `do` notation, as follows:\n\n```purescript\nx >>= f = do y <- x\n             f y\n```\n\nwhere the function argument of `f` is given the name `y`.\n\nInstances must satisfy the following law in addition to the `Apply`\nlaws:\n\n- Associativity: `(x >>= f) >>= g = x >>= (\\k => f k >>= g)`\n\nAssociativity tells us that we can regroup operations which use `do`\nnotation so that we can unambiguously write, for example:\n\n```purescript\ndo x <- m1\n   y <- m2 x\n   m3 x y\n```\n","title":"Bind","fixity":null,"info":{"arguments":[["m",null]],"declType":"typeClass","superclasses":[["Prelude.Apply",[{"tag":"TypeVar","contents":"m"}]]]},"sourceSpan":{"start":[316,1],"name":"src/Prelude.purs","end":[319,1]}},{"children":[],"comments":"`(>>=)` is an alias for `bind`.\n","title":"(>>=)","fixity":{"associativity":"infixl","precedence":1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[[["Prelude.Bind",[{"tag":"TypeVar","contents":"m"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"b"}]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[330,1],"name":"src/Prelude.purs","end":[331,1]}},{"children":[{"comments":null,"title":"monadFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Monad"},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"r"}]}]}},"sourceSpan":{"start":[345,1],"name":"src/Prelude.purs","end":[346,1]}},{"comments":null,"title":"monadArray","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Monad"},{"tag":"TypeConstructor","contents":"Prim.Array"}]}},"sourceSpan":{"start":[346,1],"name":"src/Prelude.purs","end":[359,1]}}],"comments":"The `Monad` type class combines the operations of the `Bind` and\n`Applicative` type classes. Therefore, `Monad` instances represent type\nconstructors which support sequential composition, and also lifting of\nfunctions of arbitrary arity.\n\nInstances must satisfy the following laws in addition to the\n`Applicative` and `Bind` laws:\n\n- Left Identity: `pure x >>= f = f x`\n- Right Identity: `x >>= pure = x`\n","title":"Monad","fixity":null,"info":{"arguments":[["m",null]],"declType":"typeClass","superclasses":[["Prelude.Applicative",[{"tag":"TypeVar","contents":"m"}]],["Prelude.Bind",[{"tag":"TypeVar","contents":"m"}]]]},"sourceSpan":{"start":[343,1],"name":"src/Prelude.purs","end":[345,1]}},{"children":[],"comments":"`liftM1` provides a default implementation of `(<$>)` for any\n[`Monad`](#monad), without using `(<$>)` as provided by the\n[`Functor`](#functor)-[`Monad`](#monad) superclass relationship.\n\n`liftM1` can therefore be used to write [`Functor`](#functor) instances\nas follows:\n\n```purescript\ninstance functorF :: Functor F where\n  map = liftM1\n```\n","title":"liftM1","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[[["Prelude.Monad",[{"tag":"TypeVar","contents":"m"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[359,1],"name":"src/Prelude.purs","end":[360,1]}},{"children":[],"comments":"`ap` provides a default implementation of `(<*>)` for any\n[`Monad`](#monad), without using `(<*>)` as provided by the\n[`Apply`](#apply)-[`Monad`](#monad) superclass relationship.\n\n`ap` can therefore be used to write [`Apply`](#apply) instances as\nfollows:\n\n```purescript\ninstance applyF :: Apply F where\n  apply = ap\n```\n","title":"ap","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[[["Prelude.Monad",[{"tag":"TypeVar","contents":"m"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[375,1],"name":"src/Prelude.purs","end":[376,1]}},{"children":[{"comments":null,"title":"append","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"semigroupString","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Semigroup"},{"tag":"TypeConstructor","contents":"Prim.String"}]}},"sourceSpan":{"start":[403,1],"name":"src/Prelude.purs","end":[406,1]}},{"comments":null,"title":"semigroupUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Semigroup"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[406,1],"name":"src/Prelude.purs","end":[409,1]}},{"comments":null,"title":"semigroupFn","info":{"declType":"instance","dependencies":[["Prelude.Semigroup",[{"tag":"TypeVar","contents":"s'"}]]],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Semigroup"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"s'"}]}]}},"sourceSpan":{"start":[409,1],"name":"src/Prelude.purs","end":[412,1]}},{"comments":null,"title":"semigroupOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Semigroup"},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}},"sourceSpan":{"start":[412,1],"name":"src/Prelude.purs","end":[417,1]}},{"comments":null,"title":"semigroupArray","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Semigroup"},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Array"},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[417,1],"name":"src/Prelude.purs","end":[420,1]}}],"comments":"The `Semigroup` type class identifies an associative operation on a type.\n\nInstances are required to satisfy the following law:\n\n- Associativity: `(x <> y) <> z = x <> (y <> z)`\n\nOne example of a `Semigroup` is `String`, with `(<>)` defined as string\nconcatenation.\n","title":"Semigroup","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[389,1],"name":"src/Prelude.purs","end":[392,1]}},{"children":[],"comments":"`(<>)` is an alias for `append`.\n","title":"(<>)","fixity":{"associativity":"infixr","precedence":5},"info":{"declType":"value","type":{"tag":"ForAll","contents":["s",{"tag":"ConstrainedType","contents":[[["Prelude.Semigroup",[{"tag":"TypeVar","contents":"s"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"s"}]}]}]},null]}},"sourceSpan":{"start":[396,1],"name":"src/Prelude.purs","end":[397,1]}},{"children":[],"comments":"`(++)` is an alternative alias for `append`.\n","title":"(++)","fixity":{"associativity":"infixr","precedence":5},"info":{"declType":"value","type":{"tag":"ForAll","contents":["s",{"tag":"ConstrainedType","contents":[[["Prelude.Semigroup",[{"tag":"TypeVar","contents":"s"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"s"}]}]}]},null]}},"sourceSpan":{"start":[400,1],"name":"src/Prelude.purs","end":[401,1]}},{"children":[{"comments":null,"title":"add","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"zero","info":{"declType":"typeClassMember","type":{"tag":"TypeVar","contents":"a"}},"sourceSpan":null},{"comments":null,"title":"mul","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"one","info":{"declType":"typeClassMember","type":{"tag":"TypeVar","contents":"a"}},"sourceSpan":null},{"comments":null,"title":"semiringInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Semiring"},{"tag":"TypeConstructor","contents":"Prim.Int"}]}},"sourceSpan":{"start":[445,1],"name":"src/Prelude.purs","end":[451,1]}},{"comments":null,"title":"semiringNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Semiring"},{"tag":"TypeConstructor","contents":"Prim.Number"}]}},"sourceSpan":{"start":[451,1],"name":"src/Prelude.purs","end":[457,1]}},{"comments":null,"title":"semiringUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Semiring"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[457,1],"name":"src/Prelude.purs","end":[463,1]}}],"comments":"The `Semiring` class is for types that support an addition and\nmultiplication operation.\n\nInstances must satisfy the following laws:\n\n- Commutative monoid under addition:\n  - Associativity: `(a + b) + c = a + (b + c)`\n  - Identity: `zero + a = a + zero = a`\n  - Commutative: `a + b = b + a`\n- Monoid under multiplication:\n  - Associativity: `(a * b) * c = a * (b * c)`\n  - Identity: `one * a = a * one = a`\n- Multiplication distributes over addition:\n  - Left distributivity: `a * (b + c) = (a * b) + (a * c)`\n  - Right distributivity: `(a + b) * c = (a * c) + (b * c)`\n- Annihiliation: `zero * a = a * zero = zero`\n","title":"Semiring","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[439,1],"name":"src/Prelude.purs","end":[445,1]}},{"children":[],"comments":"`(+)` is an alias for `add`.\n","title":"(+)","fixity":{"associativity":"infixl","precedence":6},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.Semiring",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[467,1],"name":"src/Prelude.purs","end":[468,1]}},{"children":[],"comments":"`(*)` is an alias for `mul`.\n","title":"(*)","fixity":{"associativity":"infixl","precedence":7},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.Semiring",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[471,1],"name":"src/Prelude.purs","end":[472,1]}},{"children":[{"comments":null,"title":"sub","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"ringInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ring"},{"tag":"TypeConstructor","contents":"Prim.Int"}]}},"sourceSpan":{"start":[489,1],"name":"src/Prelude.purs","end":[492,1]}},{"comments":null,"title":"ringNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ring"},{"tag":"TypeConstructor","contents":"Prim.Number"}]}},"sourceSpan":{"start":[492,1],"name":"src/Prelude.purs","end":[495,1]}},{"comments":null,"title":"ringUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ring"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[495,1],"name":"src/Prelude.purs","end":[498,1]}}],"comments":"The `Ring` class is for types that support addition, multiplication,\nand subtraction operations.\n\nInstances must satisfy the following law in addition to the `Semiring`\nlaws:\n\n- Additive inverse: `a - a = (zero - a) + a = zero`\n","title":"Ring","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[["Prelude.Semiring",[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[486,1],"name":"src/Prelude.purs","end":[489,1]}},{"children":[],"comments":"`(-)` is an alias for `sub`.\n","title":"(-)","fixity":{"associativity":"infixl","precedence":6},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.Ring",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[501,1],"name":"src/Prelude.purs","end":[502,1]}},{"children":[],"comments":"`negate x` can be used as a shorthand for `zero - x`.\n","title":"negate","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.Ring",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]},null]}},"sourceSpan":{"start":[505,1],"name":"src/Prelude.purs","end":[506,1]}},{"children":[{"comments":null,"title":"div","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"mod","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"moduloSemiringInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.ModuloSemiring"},{"tag":"TypeConstructor","contents":"Prim.Int"}]}},"sourceSpan":{"start":[522,1],"name":"src/Prelude.purs","end":[526,1]}},{"comments":null,"title":"moduloSemiringNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.ModuloSemiring"},{"tag":"TypeConstructor","contents":"Prim.Number"}]}},"sourceSpan":{"start":[526,1],"name":"src/Prelude.purs","end":[530,1]}},{"comments":null,"title":"moduloSemiringUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.ModuloSemiring"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[530,1],"name":"src/Prelude.purs","end":[534,1]}}],"comments":"The `ModuloSemiring` class is for types that support addition,\nmultiplication, division, and modulo (division remainder) operations.\n\nInstances must satisfy the following law in addition to the `Semiring`\nlaws:\n\n- Remainder: `a / b * b + (a `mod` b) = a`\n","title":"ModuloSemiring","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[["Prelude.Semiring",[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[518,1],"name":"src/Prelude.purs","end":[522,1]}},{"children":[],"comments":"`(/)` is an alias for `div`.\n","title":"(/)","fixity":{"associativity":"infixl","precedence":7},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.ModuloSemiring",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[537,1],"name":"src/Prelude.purs","end":[538,1]}},{"children":[{"comments":null,"title":"divisionRingNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.DivisionRing"},{"tag":"TypeConstructor","contents":"Prim.Number"}]}},"sourceSpan":{"start":[555,1],"name":"src/Prelude.purs","end":[556,1]}},{"comments":null,"title":"divisionRingUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.DivisionRing"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[556,1],"name":"src/Prelude.purs","end":[564,1]}}],"comments":"A `Ring` where every nonzero element has a multiplicative inverse.\n\nInstances must satisfy the following law in addition to the `Ring` and\n`ModuloSemiring` laws:\n\n- Multiplicative inverse: `(one / x) * x = one`\n\nAs a consequence of this ```a `mod` b = zero``` as no divide operation\nwill have a remainder.\n","title":"DivisionRing","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[["Prelude.Ring",[{"tag":"TypeVar","contents":"a"}]],["Prelude.ModuloSemiring",[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[553,1],"name":"src/Prelude.purs","end":[555,1]}},{"children":[{"comments":null,"title":"numNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Num"},{"tag":"TypeConstructor","contents":"Prim.Number"}]}},"sourceSpan":{"start":[566,1],"name":"src/Prelude.purs","end":[567,1]}},{"comments":null,"title":"numUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Num"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[567,1],"name":"src/Prelude.purs","end":[576,1]}}],"comments":"The `Num` class is for types that are commutative fields.\n\nInstances must satisfy the following law in addition to the\n`DivisionRing` laws:\n\n- Commutative multiplication: `a * b = b * a`\n","title":"Num","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[["Prelude.DivisionRing",[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[564,1],"name":"src/Prelude.purs","end":[566,1]}},{"children":[{"comments":null,"title":"eq","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}]}},"sourceSpan":null},{"comments":null,"title":"eqBoolean","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Eq"},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}},"sourceSpan":{"start":[591,1],"name":"src/Prelude.purs","end":[594,1]}},{"comments":null,"title":"eqInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Eq"},{"tag":"TypeConstructor","contents":"Prim.Int"}]}},"sourceSpan":{"start":[594,1],"name":"src/Prelude.purs","end":[597,1]}},{"comments":null,"title":"eqNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Eq"},{"tag":"TypeConstructor","contents":"Prim.Number"}]}},"sourceSpan":{"start":[597,1],"name":"src/Prelude.purs","end":[600,1]}},{"comments":null,"title":"eqChar","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Eq"},{"tag":"TypeConstructor","contents":"Prim.Char"}]}},"sourceSpan":{"start":[600,1],"name":"src/Prelude.purs","end":[603,1]}},{"comments":null,"title":"eqString","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Eq"},{"tag":"TypeConstructor","contents":"Prim.String"}]}},"sourceSpan":{"start":[603,1],"name":"src/Prelude.purs","end":[606,1]}},{"comments":null,"title":"eqUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Eq"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[606,1],"name":"src/Prelude.purs","end":[609,1]}},{"comments":null,"title":"eqArray","info":{"declType":"instance","dependencies":[["Prelude.Eq",[{"tag":"TypeVar","contents":"a"}]]],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Eq"},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Array"},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[609,1],"name":"src/Prelude.purs","end":[612,1]}},{"comments":null,"title":"eqOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Eq"},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}},"sourceSpan":{"start":[612,1],"name":"src/Prelude.purs","end":[618,1]}}],"comments":"The `Eq` type class represents types which support decidable equality.\n\n`Eq` instances should satisfy the following laws:\n\n- Reflexivity: `x == x = true`\n- Symmetry: `x == y = y == x`\n- Transitivity: if `x == y` and `y == z` then `x == z`\n","title":"Eq","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[576,1],"name":"src/Prelude.purs","end":[579,1]}},{"children":[],"comments":"`(==)` is an alias for `eq`. Tests whether one value is equal to another.\n","title":"(==)","fixity":{"associativity":"infix","precedence":4},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.Eq",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}]}]},null]}},"sourceSpan":{"start":[583,1],"name":"src/Prelude.purs","end":[584,1]}},{"children":[],"comments":"`(/=)` tests whether one value is _not equal_ to another. Shorthand for\n`not (x == y)`.\n","title":"(/=)","fixity":{"associativity":"infix","precedence":4},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.Eq",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}]}]},null]}},"sourceSpan":{"start":[588,1],"name":"src/Prelude.purs","end":[589,1]}},{"children":[{"comments":null,"title":"LT","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"GT","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"EQ","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"semigroupOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Semigroup"},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}},"sourceSpan":{"start":[412,1],"name":"src/Prelude.purs","end":[417,1]}},{"comments":null,"title":"eqOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Eq"},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}},"sourceSpan":{"start":[612,1],"name":"src/Prelude.purs","end":[618,1]}},{"comments":null,"title":"ordOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ord"},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}},"sourceSpan":{"start":[667,1],"name":"src/Prelude.purs","end":[676,1]}},{"comments":null,"title":"boundedOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Bounded"},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}},"sourceSpan":{"start":[731,1],"name":"src/Prelude.purs","end":[735,1]}},{"comments":null,"title":"boundedOrdOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.BoundedOrd"},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}},"sourceSpan":{"start":[752,1],"name":"src/Prelude.purs","end":[753,1]}},{"comments":null,"title":"showOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Show"},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}},"sourceSpan":{"start":[850,1],"name":"src/Prelude.purs","end":[855,1]}}],"comments":"The `Ordering` data type represents the three possible outcomes of\ncomparing two values:\n\n`LT` - The first value is _less than_ the second.\n`GT` - The first value is _greater than_ the second.\n`EQ` - The first value is _equal to_ the second.\n","title":"Ordering","fixity":null,"info":{"declType":"data","dataDeclType":"data","typeArguments":[]},"sourceSpan":{"start":[628,1],"name":"src/Prelude.purs","end":[638,1]}},{"children":[{"comments":null,"title":"compare","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}]}},"sourceSpan":null},{"comments":null,"title":"ordBoolean","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ord"},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}},"sourceSpan":{"start":[641,1],"name":"src/Prelude.purs","end":[644,1]}},{"comments":null,"title":"ordInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ord"},{"tag":"TypeConstructor","contents":"Prim.Int"}]}},"sourceSpan":{"start":[644,1],"name":"src/Prelude.purs","end":[647,1]}},{"comments":null,"title":"ordNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ord"},{"tag":"TypeConstructor","contents":"Prim.Number"}]}},"sourceSpan":{"start":[647,1],"name":"src/Prelude.purs","end":[650,1]}},{"comments":null,"title":"ordString","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ord"},{"tag":"TypeConstructor","contents":"Prim.String"}]}},"sourceSpan":{"start":[650,1],"name":"src/Prelude.purs","end":[653,1]}},{"comments":null,"title":"ordChar","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ord"},{"tag":"TypeConstructor","contents":"Prim.Char"}]}},"sourceSpan":{"start":[653,1],"name":"src/Prelude.purs","end":[656,1]}},{"comments":null,"title":"ordUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ord"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[656,1],"name":"src/Prelude.purs","end":[659,1]}},{"comments":null,"title":"ordArray","info":{"declType":"instance","dependencies":[["Prelude.Ord",[{"tag":"TypeVar","contents":"a"}]]],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ord"},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Array"},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[659,1],"name":"src/Prelude.purs","end":[665,1]}},{"comments":null,"title":"ordOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Ord"},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}},"sourceSpan":{"start":[667,1],"name":"src/Prelude.purs","end":[676,1]}}],"comments":"The `Ord` type class represents types which support comparisons with a\n_total order_.\n\n`Ord` instances should satisfy the laws of total orderings:\n\n- Reflexivity: `a <= a`\n- Antisymmetry: if `a <= b` and `b <= a` then `a = b`\n- Transitivity: if `a <= b` and `b <= c` then `a <= c`\n","title":"Ord","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[["Prelude.Eq",[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[638,1],"name":"src/Prelude.purs","end":[641,1]}},{"children":[],"comments":"Test whether one value is _strictly less than_ another.\n","title":"(<)","fixity":{"associativity":"infixl","precedence":4},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.Ord",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}]}]},null]}},"sourceSpan":{"start":[682,1],"name":"src/Prelude.purs","end":[683,1]}},{"children":[],"comments":"Test whether one value is _strictly greater than_ another.\n","title":"(>)","fixity":{"associativity":"infixl","precedence":4},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.Ord",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}]}]},null]}},"sourceSpan":{"start":[688,1],"name":"src/Prelude.purs","end":[689,1]}},{"children":[],"comments":"Test whether one value is _non-strictly less than_ another.\n","title":"(<=)","fixity":{"associativity":"infixl","precedence":4},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.Ord",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}]}]},null]}},"sourceSpan":{"start":[694,1],"name":"src/Prelude.purs","end":[695,1]}},{"children":[],"comments":"Test whether one value is _non-strictly greater than_ another.\n","title":"(>=)","fixity":{"associativity":"infixl","precedence":4},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.Ord",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}]}]},null]}},"sourceSpan":{"start":[700,1],"name":"src/Prelude.purs","end":[701,1]}},{"children":[{"comments":null,"title":"top","info":{"declType":"typeClassMember","type":{"tag":"TypeVar","contents":"a"}},"sourceSpan":null},{"comments":null,"title":"bottom","info":{"declType":"typeClassMember","type":{"tag":"TypeVar","contents":"a"}},"sourceSpan":null},{"comments":null,"title":"boundedBoolean","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Bounded"},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}},"sourceSpan":{"start":[723,1],"name":"src/Prelude.purs","end":[727,1]}},{"comments":null,"title":"boundedUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Bounded"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[727,1],"name":"src/Prelude.purs","end":[731,1]}},{"comments":null,"title":"boundedOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Bounded"},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}},"sourceSpan":{"start":[731,1],"name":"src/Prelude.purs","end":[735,1]}},{"comments":null,"title":"boundedInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Bounded"},{"tag":"TypeConstructor","contents":"Prim.Int"}]}},"sourceSpan":{"start":[735,1],"name":"src/Prelude.purs","end":[739,1]}},{"comments":null,"title":"boundedFn","info":{"declType":"instance","dependencies":[["Prelude.Bounded",[{"tag":"TypeVar","contents":"b"}]]],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Bounded"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[739,1],"name":"src/Prelude.purs","end":[748,1]}}],"comments":"The `Bounded` type class represents types that are finite.\n\nAlthough there are no \"internal\" laws for `Bounded`, every value of `a`\nshould be considered less than or equal to `top` by some means, and greater\nthan or equal to `bottom`.\n\nThe lack of explicit `Ord` constraint allows flexibility in the use of\n`Bounded` so it can apply to total and partially ordered sets, boolean\nalgebras, etc.\n","title":"Bounded","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[719,1],"name":"src/Prelude.purs","end":[723,1]}},{"children":[{"comments":null,"title":"boundedOrdBoolean","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.BoundedOrd"},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}},"sourceSpan":{"start":[750,1],"name":"src/Prelude.purs","end":[751,1]}},{"comments":null,"title":"boundedOrdUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.BoundedOrd"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[751,1],"name":"src/Prelude.purs","end":[752,1]}},{"comments":null,"title":"boundedOrdOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.BoundedOrd"},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}},"sourceSpan":{"start":[752,1],"name":"src/Prelude.purs","end":[753,1]}},{"comments":null,"title":"boundedOrdInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.BoundedOrd"},{"tag":"TypeConstructor","contents":"Prim.Int"}]}},"sourceSpan":{"start":[753,1],"name":"src/Prelude.purs","end":[784,1]}}],"comments":"The `BoundedOrd` type class represents totally ordered finite data types.\n\nInstances should satisfy the following law in addition to the `Ord` laws:\n\n- Ordering: `bottom <= a <= top`\n","title":"BoundedOrd","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[["Prelude.Bounded",[{"tag":"TypeVar","contents":"a"}]],["Prelude.Ord",[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[748,1],"name":"src/Prelude.purs","end":[750,1]}},{"children":[{"comments":null,"title":"conj","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"disj","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"not","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}},"sourceSpan":null},{"comments":null,"title":"booleanAlgebraBoolean","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.BooleanAlgebra"},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}},"sourceSpan":{"start":[789,1],"name":"src/Prelude.purs","end":[794,1]}},{"comments":null,"title":"booleanAlgebraUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.BooleanAlgebra"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[794,1],"name":"src/Prelude.purs","end":[799,1]}},{"comments":null,"title":"booleanAlgebraFn","info":{"declType":"instance","dependencies":[["Prelude.BooleanAlgebra",[{"tag":"TypeVar","contents":"b"}]]],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.BooleanAlgebra"},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]}},"sourceSpan":{"start":[799,1],"name":"src/Prelude.purs","end":[804,1]}}],"comments":"The `BooleanAlgebra` type class represents types that behave like boolean\nvalues.\n\nInstances should satisfy the following laws in addition to the `Bounded`\nlaws:\n\n- Associativity:\n  - `a || (b || c) = (a || b) || c`\n  - `a && (b && c) = (a && b) && c`\n- Commutativity:\n  - `a || b = b || a`\n  - `a && b = b && a`\n- Distributivity:\n  - `a && (b || c) = (a && b) || (a && c)`\n  - `a || (b && c) = (a || b) && (a || c)`\n- Identity:\n  - `a || bottom = a`\n  - `a && top = a`\n- Idempotent:\n  - `a || a = a`\n  - `a && a = a`\n- Absorption:\n  - `a || (a && b) = a`\n  - `a && (a || b) = a`\n- Annhiliation:\n  - `a || top = top`\n- Complementation:\n  - `a && not a = bottom`\n  - `a || not a = top`\n","title":"BooleanAlgebra","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[["Prelude.Bounded",[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[784,1],"name":"src/Prelude.purs","end":[789,1]}},{"children":[],"comments":"`(&&)` is an alias for `conj`.\n","title":"(&&)","fixity":{"associativity":"infixr","precedence":3},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.BooleanAlgebra",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[808,1],"name":"src/Prelude.purs","end":[809,1]}},{"children":[],"comments":"`(||)` is an alias for `disj`.\n","title":"(||)","fixity":{"associativity":"infixr","precedence":2},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[["Prelude.BooleanAlgebra",[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[812,1],"name":"src/Prelude.purs","end":[813,1]}},{"children":[{"comments":null,"title":"show","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Function"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":"Prim.String"}]}},"sourceSpan":null},{"comments":null,"title":"showBoolean","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Show"},{"tag":"TypeConstructor","contents":"Prim.Boolean"}]}},"sourceSpan":{"start":[828,1],"name":"src/Prelude.purs","end":[832,1]}},{"comments":null,"title":"showInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Show"},{"tag":"TypeConstructor","contents":"Prim.Int"}]}},"sourceSpan":{"start":[832,1],"name":"src/Prelude.purs","end":[835,1]}},{"comments":null,"title":"showNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Show"},{"tag":"TypeConstructor","contents":"Prim.Number"}]}},"sourceSpan":{"start":[835,1],"name":"src/Prelude.purs","end":[838,1]}},{"comments":null,"title":"showChar","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Show"},{"tag":"TypeConstructor","contents":"Prim.Char"}]}},"sourceSpan":{"start":[838,1],"name":"src/Prelude.purs","end":[841,1]}},{"comments":null,"title":"showString","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Show"},{"tag":"TypeConstructor","contents":"Prim.String"}]}},"sourceSpan":{"start":[841,1],"name":"src/Prelude.purs","end":[844,1]}},{"comments":null,"title":"showUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Show"},{"tag":"TypeConstructor","contents":"Prelude.Unit"}]}},"sourceSpan":{"start":[844,1],"name":"src/Prelude.purs","end":[847,1]}},{"comments":null,"title":"showArray","info":{"declType":"instance","dependencies":[["Prelude.Show",[{"tag":"TypeVar","contents":"a"}]]],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Show"},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prim.Array"},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[847,1],"name":"src/Prelude.purs","end":[850,1]}},{"comments":null,"title":"showOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":"Prelude.Show"},{"tag":"TypeConstructor","contents":"Prelude.Ordering"}]}},"sourceSpan":{"start":[850,1],"name":"src/Prelude.purs","end":[855,1]}}],"comments":"The `Show` type class represents those types which can be converted into\na human-readable `String` representation.\n\nWhile not required, it is recommended that for any expression `x`, the\nstring `show x` be executable PureScript code which evaluates to the same\nvalue as the expression `x`.\n","title":"Show","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[825,1],"name":"src/Prelude.purs","end":[828,1]}}]}],"resolvedDependencies":{},"bookmarks":[{"package":null,"item":["Prelude","Unit"]},{"package":null,"item":["Prelude","unit"]},{"package":null,"item":["Prelude","($)"]},{"package":null,"item":["Prelude","(#)"]},{"package":null,"item":["Prelude","($)"]},{"package":null,"item":["Prelude","(#)"]},{"package":null,"item":["Prelude","flip"]},{"package":null,"item":["Prelude","const"]},{"package":null,"item":["Prelude","asTypeOf"]},{"package":null,"item":["Prelude","otherwise"]},{"package":null,"item":["Prelude","Semigroupoid"]},{"package":null,"item":["Prelude","semigroupoidFn"]},{"package":null,"item":["Prelude","(>>>)"]},{"package":null,"item":["Prelude","(<<<)"]},{"package":null,"item":["Prelude","(<<<)"]},{"package":null,"item":["Prelude","(>>>)"]},{"package":null,"item":["Prelude","Category"]},{"package":null,"item":["Prelude","categoryFn"]},{"package":null,"item":["Prelude","Functor"]},{"package":null,"item":["Prelude","functorFn"]},{"package":null,"item":["Prelude","functorArray"]},{"package":null,"item":["Prelude","(<$>)"]},{"package":null,"item":["Prelude","(<#>)"]},{"package":null,"item":["Prelude","(<$>)"]},{"package":null,"item":["Prelude","(<#>)"]},{"package":null,"item":["Prelude","void"]},{"package":null,"item":["Prelude","Apply"]},{"package":null,"item":["Prelude","applyFn"]},{"package":null,"item":["Prelude","applyArray"]},{"package":null,"item":["Prelude","(<*>)"]},{"package":null,"item":["Prelude","(<*>)"]},{"package":null,"item":["Prelude","Applicative"]},{"package":null,"item":["Prelude","applicativeFn"]},{"package":null,"item":["Prelude","applicativeArray"]},{"package":null,"item":["Prelude","return"]},{"package":null,"item":["Prelude","liftA1"]},{"package":null,"item":["Prelude","Bind"]},{"package":null,"item":["Prelude","bindFn"]},{"package":null,"item":["Prelude","bindArray"]},{"package":null,"item":["Prelude","(>>=)"]},{"package":null,"item":["Prelude","(>>=)"]},{"package":null,"item":["Prelude","Monad"]},{"package":null,"item":["Prelude","monadFn"]},{"package":null,"item":["Prelude","monadArray"]},{"package":null,"item":["Prelude","liftM1"]},{"package":null,"item":["Prelude","ap"]},{"package":null,"item":["Prelude","Semigroup"]},{"package":null,"item":["Prelude","(<>)"]},{"package":null,"item":["Prelude","(++)"]},{"package":null,"item":["Prelude","(<>)"]},{"package":null,"item":["Prelude","(++)"]},{"package":null,"item":["Prelude","semigroupString"]},{"package":null,"item":["Prelude","semigroupUnit"]},{"package":null,"item":["Prelude","semigroupFn"]},{"package":null,"item":["Prelude","semigroupOrdering"]},{"package":null,"item":["Prelude","semigroupArray"]},{"package":null,"item":["Prelude","Semiring"]},{"package":null,"item":["Prelude","semiringInt"]},{"package":null,"item":["Prelude","semiringNumber"]},{"package":null,"item":["Prelude","semiringUnit"]},{"package":null,"item":["Prelude","(+)"]},{"package":null,"item":["Prelude","(*)"]},{"package":null,"item":["Prelude","(+)"]},{"package":null,"item":["Prelude","(*)"]},{"package":null,"item":["Prelude","Ring"]},{"package":null,"item":["Prelude","ringInt"]},{"package":null,"item":["Prelude","ringNumber"]},{"package":null,"item":["Prelude","ringUnit"]},{"package":null,"item":["Prelude","(-)"]},{"package":null,"item":["Prelude","(-)"]},{"package":null,"item":["Prelude","negate"]},{"package":null,"item":["Prelude","ModuloSemiring"]},{"package":null,"item":["Prelude","moduloSemiringInt"]},{"package":null,"item":["Prelude","moduloSemiringNumber"]},{"package":null,"item":["Prelude","moduloSemiringUnit"]},{"package":null,"item":["Prelude","(/)"]},{"package":null,"item":["Prelude","(/)"]},{"package":null,"item":["Prelude","DivisionRing"]},{"package":null,"item":["Prelude","divisionRingNumber"]},{"package":null,"item":["Prelude","divisionRingUnit"]},{"package":null,"item":["Prelude","Num"]},{"package":null,"item":["Prelude","numNumber"]},{"package":null,"item":["Prelude","numUnit"]},{"package":null,"item":["Prelude","Eq"]},{"package":null,"item":["Prelude","(==)"]},{"package":null,"item":["Prelude","(/=)"]},{"package":null,"item":["Prelude","(==)"]},{"package":null,"item":["Prelude","(/=)"]},{"package":null,"item":["Prelude","eqBoolean"]},{"package":null,"item":["Prelude","eqInt"]},{"package":null,"item":["Prelude","eqNumber"]},{"package":null,"item":["Prelude","eqChar"]},{"package":null,"item":["Prelude","eqString"]},{"package":null,"item":["Prelude","eqUnit"]},{"package":null,"item":["Prelude","eqArray"]},{"package":null,"item":["Prelude","eqOrdering"]},{"package":null,"item":["Prelude","Ordering"]},{"package":null,"item":["Prelude","Ord"]},{"package":null,"item":["Prelude","ordBoolean"]},{"package":null,"item":["Prelude","ordInt"]},{"package":null,"item":["Prelude","ordNumber"]},{"package":null,"item":["Prelude","ordString"]},{"package":null,"item":["Prelude","ordChar"]},{"package":null,"item":["Prelude","ordUnit"]},{"package":null,"item":["Prelude","ordArray"]},{"package":null,"item":["Prelude","ordOrdering"]},{"package":null,"item":["Prelude","(<)"]},{"package":null,"item":["Prelude","(>)"]},{"package":null,"item":["Prelude","(<=)"]},{"package":null,"item":["Prelude","(>=)"]},{"package":null,"item":["Prelude","(<)"]},{"package":null,"item":["Prelude","(>)"]},{"package":null,"item":["Prelude","(<=)"]},{"package":null,"item":["Prelude","(>=)"]},{"package":null,"item":["Prelude","Bounded"]},{"package":null,"item":["Prelude","boundedBoolean"]},{"package":null,"item":["Prelude","boundedUnit"]},{"package":null,"item":["Prelude","boundedOrdering"]},{"package":null,"item":["Prelude","boundedInt"]},{"package":null,"item":["Prelude","boundedFn"]},{"package":null,"item":["Prelude","BoundedOrd"]},{"package":null,"item":["Prelude","boundedOrdBoolean"]},{"package":null,"item":["Prelude","boundedOrdUnit"]},{"package":null,"item":["Prelude","boundedOrdOrdering"]},{"package":null,"item":["Prelude","boundedOrdInt"]},{"package":null,"item":["Prelude","BooleanAlgebra"]},{"package":null,"item":["Prelude","booleanAlgebraBoolean"]},{"package":null,"item":["Prelude","booleanAlgebraUnit"]},{"package":null,"item":["Prelude","booleanAlgebraFn"]},{"package":null,"item":["Prelude","(&&)"]},{"package":null,"item":["Prelude","(||)"]},{"package":null,"item":["Prelude","(&&)"]},{"package":null,"item":["Prelude","(||)"]},{"package":null,"item":["Prelude","Show"]},{"package":null,"item":["Prelude","showBoolean"]},{"package":null,"item":["Prelude","showInt"]},{"package":null,"item":["Prelude","showNumber"]},{"package":null,"item":["Prelude","showChar"]},{"package":null,"item":["Prelude","showString"]},{"package":null,"item":["Prelude","showUnit"]},{"package":null,"item":["Prelude","showArray"]},{"package":null,"item":["Prelude","showOrdering"]}],"version":"999.0.2","github":["purescript","purescript-prelude"],"versionTag":"v999.0.2"}
